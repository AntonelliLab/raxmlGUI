import electron from 'electron';
import { serializeError } from 'serialize-error';
import newGithubIssueUrl from 'new-github-issue-url';
import cleanStack from 'clean-stack';
import * as ipc from 'electron-better-ipc';

import { activeWindow } from '../main/utils/utils';

export const is = {
  macos: process.platform === 'darwin',
  linux: process.platform === 'linux',
  windows: process.platform === 'win32',
  main: process.type === 'browser',
  renderer: process.type === 'renderer',
  development: process.env.NODE_ENV === 'development',
  macAppStore: process.mas === true,
  windowsStore: process.windowsStore === true,
};

export const platform = (object) => {
  let { platform } = process;
  if (is.macos) {
    platform = 'macos';
  } else if (is.windows) {
    platform = 'windows';
  }
  const fn = platform in object ? object[platform] : object.default;
  return typeof fn === 'function' ? fn() : fn;
};

// TODO: Had to replace this debug info on renderer, because electron remote module is no longer available.
// If needed, one would need to use the context bridge
export const debugInfo = () =>
  is.main
    ? `${electron.app.getName()} ${electron.app.getVersion()}
Electron ${node.electronVersion}
${process.platform} ${os.release()}
Locale: ${electron.app.getLocale()}
`.trim()
    : `Debug info not available in renderer.`;

if (is.renderer) {
  ipc.ipcRenderer.answerMain('get-state-report', async () => {
    const storeModule = await import('../app/store');
    const store = storeModule.default;
    const report = store.generateReport();
    return report;
  });
}

const getActiveState = async () => {
  if (is.renderer) {
    return window.store.generateReport();
  }
  const win = activeWindow();
  const report = await ipc.ipcMain.callRenderer(win, 'get-state-report');
  return report;
}

const getActiveStateSync = () => {
  if (is.renderer) {
    return window.store.generateReport();
  }
  return `Current state not available on synchronous call from main`;
}

const serializeAndCleanError = (error) => {
  const err = serializeError(error);
  err.stack = cleanStack(error.stack);
  return err;
}

export function timeout(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export const quote = dir => is.windows ? `"${dir}"` : dir;

const stringify = json => JSON.stringify(json, null, '  ');

const stringifyToGithubMarkdown = (json) => `\`\`\`json
${stringify(json)}
\`\`\``;

const createReportBodyForGithub = (error, activeState) => `Autogenerated report:
${stringifyToGithubMarkdown(serializeAndCleanError(error))}

Active state:
${stringifyToGithubMarkdown(activeState)}

---

Process: ${is.renderer ? 'renderer' : 'main'}
${debugInfo()}`;

const createReportBodyForMail = (error, activeState) => encodeURI(`Autogenerated report:
${stringify(serializeAndCleanError(error))}

Active state:
${stringify(activeState)}

---

Process: ${is.renderer ? 'renderer' : 'main'}
${debugInfo()}`);

const openNewGitHubIssue = (options) => {
  const url = newGithubIssueUrl(options);
  electron.shell.openExternal(url);
};

export const reportIssueToGitHub = async (error) => {
  const activeState = await getActiveState();
  openNewGitHubIssue({
    user: 'AntonelliLab',
    repo: 'raxmlGUI',
    title: error.name,
    body: createReportBodyForGithub(error, activeState),
  });
}

export const getMailtoLinkToReportError = (error) => {
  const activeState = getActiveStateSync();
  const mailtoLinkContent = `mailto:raxmlgui.help@googlemail.com?subject=${encodeURI(error.name)}&body=${createReportBodyForMail(error, activeState)}`;
  return mailtoLinkContent;
}
